<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binance Futures EMA Analizi</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body>
    <button onclick="loadData()">Verileri Yükle</button>
    <div id="result"></div>

    <script>
        async function loadData() {
            document.getElementById('result').innerText = 'Yükleniyor...';
            try {
                const symbols = await getSymbols();
                console.log('Symbols:', symbols);
                const data = await getHistoricalData(symbols);
                console.log('Historical Data:', data);
                const emaCrosses = calculateEMACrosses(data);
                console.log('EMA Crosses:', emaCrosses);
                displayResults(emaCrosses, data);
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('result').innerText = 'Veri yüklenirken bir hata oluştu.';
            }
        }

        async function getSymbols() {
            try {
                const response = await axios.get('https://fapi.binance.com/fapi/v1/exchangeInfo');
                return response.data.symbols
                    .filter(symbol => symbol.quoteAsset === 'USDT' && symbol.contractType === 'PERPETUAL')
                    .map(symbol => symbol.symbol);
            } catch (error) {
                console.error('Error fetching symbols:', error);
                return [];
            }
        }

        async function getHistoricalData(symbols) {
            const data = {};
            for (const symbol of symbols) {
                try {
                    const response = await axios.get(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=5m&limit=25`);
                    data[symbol] = response.data.map(candle => ({
                        time: candle[0],
                        close: parseFloat(candle[4]),
                        volume: parseFloat(candle[5])
                    }));
                } catch (error) {
                    console.error(`Error fetching data for ${symbol}:`, error);
                }
            }
            return data;
        }

        function calculateEMACrosses(data) {
            const emaCrosses = [];
            for (const symbol in data) {
                const closes = data[symbol].map(candle => candle.close);
                const shortEma = calculateEMA(closes, 14);
                const longEma = calculateEMA(closes, 25);
                if (shortEma[shortEma.length - 1] > longEma[longEma.length - 1] && shortEma[shortEma.length - 2] <= longEma[longEma.length - 2]) {
                    emaCrosses.push(symbol);
                }
            }
            return emaCrosses;
        }

        function calculateEMA(data, period) {
            const k = 2 / (period + 1);
            const emaArray = [data[0]];
            for (let i = 1; i < data.length; i++) {
                emaArray.push(data[i] * k + emaArray[i - 1] * (1 - k));
            }
            return emaArray;
        }

        function displayResults(emaCrosses, data) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = '<h3>EMA Kesişim Noktaları:</h3>';
            const totalVolume = Object.values(data).reduce((sum, candles) => sum + candles[candles.length - 1].volume, 0);
            emaCrosses.forEach(symbol => {
                const volume = data[symbol][data[symbol].length - 1].volume;
                const volumeRatio = (volume / totalVolume * 100).toFixed(2);
                resultDiv.innerHTML += `<p>${symbol} - Hacim: ${volume} - Oran: ${volumeRatio}%</p>`;
            });
        }
    </script>
</body>
</html>
